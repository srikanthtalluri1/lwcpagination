import getStatusStageCounts from '@salesforce/apex/AWP_WaiverHandlerClass.getStatusStage';
statusStageArray=[];
get tableCondition() {
    console.log('Checking 193');
    const list = this._filteredFieldValues || [];
    const result = list.some(category =>
        category?.isStatusStage || category?.isApplicationStandard // <-- check spelling
    );
    console.log('tableCondition:', result);
    return result;
    }

 addChildrenToFilteredValues() {
           

            this._filteredFieldValues = this._filteredFieldValues.map(filterGroup => {
                return {
                    ...filterGroup,
                    filteredFieldValue: filterGroup.filteredFieldValue.map(parent => {
                        console.log('parent.value ', parent.value);
                        const sourceArray = filterGroup.filterField === 'Status' ? this.statusStageArray : this.appDomainArray;
                        const match = sourceArray?.find(
                            cat => this.removeCount(cat.label) === parent.value
                        );

                        return {
                            ...parent,
                            children: match ? match.domains : []
                        };
                    })
                };
            });
            console.log('this._filteredFieldValues 330 ', JSON.stringify(this._filteredFieldValues));
        }

        removeCount(label) {
            return label.replace(/\s*\(\d+\)$/, '');
        }




handleFilterSearch(event) {

    try {
        const searchKey = (event.target.value || '').toLowerCase();
        this.isfilterParam = true;

        const selectedFilterApiNames = (this.selectedFilter || '').split(';').filter(x => x);
        if (!selectedFilterApiNames.length) return;

        // STEP 1: Capture current checked state (plain JSON only)
        const checkedMap = new Map();
        (this.checkedAffStdArray || []).forEach(group => {
            (group.filteredFieldValue || []).forEach(parent => {
                checkedMap.set(parent.id, !!parent.checked);
                (parent.children || []).forEach(child => {
                    checkedMap.set(child.label, !!child.checked);
                });
            });
        });

        // STEP 2: Fetch fresh unique values
        getUniqueValues({
            fieldApiName: selectedFilterApiNames,
            allOrMy: this.selectedWaiver,
            isfilterParam: this.isfilterParam
        })
        .then(data => {

            if (!data) {
                this._filteredFieldValues = [];
                return;
            }

            /** -----------------------------
             * Normalize Domain/Status arrays
             * ----------------------------- */
            const normalizeDomainList = arr => {
                return (arr || []).map(item => ({
                    ...item,
                    domains: (item.domains || []).map(d => ({
                        ...d,
                        checked: false // enforce JSON safety
                    }))
                }));
            };

            this.appDomainArray = normalizeDomainList(data.modifedAffectedStandard);
            this.statusStageArray = normalizeDomainList(data.listSatausStage);

            /** -----------------------------
             * Step 3: Build filter groups
             * ----------------------------- */
            const rebuiltGroups = Object.keys(data)
                .filter(key => !['PortfolioDomains', 'modifedAffectedStandard', 'listSatausStage'].includes(key))
                .map((key, index) => {
                    const filterOption = this._filterOptions.find(opt => opt.value === key);
                    if (!filterOption) return null;

                    const items = (data[key] || []).map(v => ({
                        label: `${v.value ? v.value : 'No Data'} (${v.count})`,
                        value: v.value || 'nullcheck',
                        id: v.id || 'nullcheck',
                        checked: false,
                        children: [] // ensure JSON-safe children list
                    }));

                    return {
                        id: index,
                        filterField: filterOption.label,
                        filterFieldApiName: key,
                        filteredFieldValue: items,
                        selectedValue: [],
                        showValues: true,
                        icon: 'utility:chevrondown',
                        isApplicationStandred: filterOption.label === 'Affected Standard',
                        isStatusStage: filterOption.label === 'Status'
                    };
                })
                .filter(Boolean);

            this._filteredFieldValues = rebuiltGroups;

            /** -----------------------------
             * Step 4: Add children (domains/status)
             * ----------------------------- */
            this._filteredFieldValues = this._filteredFieldValues.map(group => {
                return {
                    ...group,
                    filteredFieldValue: group.filteredFieldValue.map(parent => {
                        const clean = label => label.replace(/\s*\(\d+\)\s*$/, '');

                        const matching =
                            group.filterField === 'Status'
                                ? this.statusStageArray?.find(x => clean(x.label) === clean(parent.value))
                                : this.appDomainArray?.find(x => clean(x.label) === clean(parent.value));

                        return {
                            ...parent,
                            children: (matching?.domains || []).map(child => ({
                                label: child.label,
                                value: child.value,
                                checked: false
                            }))
                        };
                    })
                };
            });

            /** -----------------------------
             * Step 5: Apply search filter
             * ----------------------------- */
            const filtered = this._filteredFieldValues.map(group => {
                const filteredValues = group.filteredFieldValue
                    .map(parent => {
                        const parentMatch = parent.label.toLowerCase().includes(searchKey);
                        const matchingChildren = (parent.children || []).filter(child =>
                            child.label.toLowerCase().includes(searchKey)
                        );

                        if (parentMatch) {
                            return { ...parent, children: [...parent.children] };
                        }
                        if (matchingChildren.length > 0) {
                            return { ...parent, children: matchingChildren };
                        }
                        return null;
                    })
                    .filter(Boolean);

                return { ...group, filteredFieldValue: filteredValues };
            });

            /** -----------------------------
             * Step 6: Restore checkmarks safely
             * ----------------------------- */
            const cleaned = filtered.map(group => {
                return {
                    ...group,
                    filteredFieldValue: group.filteredFieldValue.map(parent => {
                        const restoredParent = {
                            ...parent,
                            checked: checkedMap.get(parent.id) || false
                        };
                        return {
                            ...restoredParent,
                            children: (parent.children || []).map(child => ({
                                ...child,
                                checked: checkedMap.get(child.label) || false
                            }))
                        };
                    })
                };
            });

            // FINAL: store JSON-clean version only
            this._filteredFieldValues = JSON.parse(JSON.stringify(cleaned));
            this.checkedAffStdArray = JSON.parse(JSON.stringify(cleaned));
            this.isfilterParam = false;
        })
        .catch(err => {
            console.error('handleFilterSearch ERROR:', err);
            this.isfilterParam = false;
        });

    } catch (ex) {
        console.error('handleFilterSearch outer exception:', ex);
    }
}

 // Utility function to normalize any domain array
                        const normalizeDomains = (arr) =>
                            arr?.map(domain => ({
                                ...domain,
                                domains: domain.domains.map(eachDomain => ({
                                    ...eachDomain,
                                    checked: false
                                }))
                            })) || [];

                        // Assign and normalize in one step
                        this.appDomainArray = normalizeDomains(data?.['modifedAffectedStandard']);
                        this.statusStageArray = normalizeDomains(data?.['listSatausStage']);

                       //this.appDomainArray= data?.['modifedAffectedStandard'];
                        //this.statusStageArray= data?.['listSatausStage'];
                        console.log('appDomainArray data ', JSON.stringify(this.appDomainArray));
                        console.log('appDomainArray data 2183', JSON.stringify(this.statusStageArray));

 isStatusStage: (this._filterOptions.filter(t => t.value === Object.keys(x)[0])[0].label) === 'Status'

/ Helper to trim labels
const clean = label => label?.replace(/\s*\(.*?\)\s*/g, '').trim() || '';

// Clone filters for immutability
const updatedFilters = [...this._filteredFieldValues];

// Find which parent contains the changed category
const parentIndex = updatedFilters.findIndex(parent =>
    parent.filteredFieldValue.some(cat =>
        clean(cat.label) === clean(categoryName) ||
        cat.children?.some(ch => clean(ch.label) === clean(categoryName))
    )
);

if (parentIndex !== -1) {
    const parentFilter = updatedFilters[parentIndex];

    parentFilter.filteredFieldValue = parentFilter.filteredFieldValue.map(category => {
        // Toggle parent
        if (clean(category.label) === clean(categoryName)) {
            category.checked = isChecked;
            if (!isChecked) {
                category.children = category.children.map(c => ({ ...c, checked: false }));
            }
        }

        // Toggle child
        if (category.children?.length > 0) {
            category.children = category.children.map(child => {
                if (clean(child.label) === clean(categoryName)) {
                    child.checked = isChecked;
                }
                return child;
            });
        }
        return category;
    });

    updatedFilters[parentIndex] = { ...parentFilter };
}

// ✅ Only now assign back
this._filteredFieldValues = updatedFilters;

// ✅ Build filters array (optional)
this.filters = updatedFilters
    .map((filter, idx) => {
        const selectedValues = [];
        filter.filteredFieldValue.forEach(cat => {
            if (cat.checked) selectedValues.push(clean(cat.label));
            const checkedChildren = cat.children?.filter(c => c.checked).map(c => clean(c.label));
            if (checkedChildren?.length) selectedValues.push(...checkedChildren);
        });
        return selectedValues.length
            ? { [filter.filterField]: selectedValues, uniqueKey: `${idx}-${selectedValues.join(',')}` }
            : null;
    })
    .filter(Boolean);

console.log('✅ Filters:', JSON.stringify(this.filters, null, 2));
