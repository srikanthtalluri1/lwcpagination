// -------- Helpers --------
    private static Map<String,String> tdLabels() {
        Map<String, Schema.SObjectField> f = TechnologyDecision__c.SObjectType.getDescribe().fields.getMap();
        Map<String,String> labels = new Map<String,String>();
        labels.put('Status',          f.get('Status__c').getDescribe().getLabel());
        labels.put('Stage',           f.get('Stage__c').getDescribe().getLabel());
        labels.put('DecisionReason',  f.get('Decision_Reason__c').getDescribe().getLabel());
        return labels;
    }

    private static void seed() {
        insert new List<TechnologyDecision__c>{
            new TechnologyDecision__c(Name='Alpha TD',   Status__c='Approved', Stage__c='Init',   Decision_Reason__c='Cost'),
            new TechnologyDecision__c(Name='Bravo TD',   Status__c='Approved', Stage__c='Review'),   // null reason
            new TechnologyDecision__c(Name='Charlie TD', Status__c='Approved', Stage__c='Final',  Decision_Reason__c='Risk'),
            new TechnologyDecision__c(Name='Delta TD',   Status__c='Draft',    Stage__c='Init',   Decision_Reason__c='Scope')
        };
    }

    // Build a filter JSON safely using the org's actual labels; only include a key if the label resolves to an API name in handler.
    private static String buildFilters(Map<String, List<Object>> labelToValues) {
        List<Object> filters = new List<Object>();
        Map<String,String> L = tdLabels();

        for (String logicalKey : labelToValues.keySet()) {
            String label;
            if (logicalKey == 'Status')         label = L.get('Status');
            else if (logicalKey == 'Stage')     label = L.get('Stage');
            else if (logicalKey == 'DecisionReason') label = L.get('DecisionReason');
            else continue;

            // Ask the handler to resolve label→API to ensure it exists; skip key if not resolvable in this org.
            List<String> apiNames = TechnologyDecision_DataTableHandler.getApiNamesFromLabels('TechnologyDecision__c', label);
            if (apiNames == null || apiNames.isEmpty()) continue;

            filters.add(new Map<String,Object>{ label => (List<Object>)labelToValues.get(logicalKey) });
        }
        return JSON.serialize(filters);
    }

    // -------- Tests --------

    // 1) Base call + search → exercises buildSearchTerm
    @IsTest
    static void t_base_and_search() {
        seed();

        // Base (no filters)
        Test.startTest();
        Map<String,Object> res1 = TechnologyDecision_DataTableHandler.getTechnologyDecision(0, 200, null, 'alldecision', null);
        Test.stopTest();
        System.assertNotEquals(null, res1, 'Base result should not be null');

        // Search (LIKE on multiple fields)
        Test.startTest();
        Map<String,Object> res2 = TechnologyDecision_DataTableHandler.getTechnologyDecision(0, 200, null, 'alldecision', 'Alpha');
        Test.stopTest();
        System.assert(res2.containsKey('decisionRecords'), 'Should return records for search');
    }

    // 2) Filters → ONLY nullcheck on DecisionReason (builds " = NULL") + cleanup branch with empty filter
    @IsTest
    static void t_filters_null_only_and_cleanup() {
        seed();
        Map<String, List<Object>> map1 = new Map<String, List<Object>>();
        map1.put('DecisionReason', new List<Object>{ 'nullcheck' }); // only nullcheck
        // Empty filter to trigger the "(" cleanup path
        map1.put('Status', new List<Object>{}); // empty list; causes dangling "(" then cleanup

        String filters = buildFilters(map1);

        Test.startTest();
        Map<String,Object> res = TechnologyDecision_DataTableHandler.getTechnologyDecision(0, 200, filters, 'alldecision', null);
        Test.stopTest();
        System.assertNotEquals(null, res, 'Filter result should not be null');
    }

    // 3) Filters → values + nullcheck on DecisionReason AND a Stage multi-value IN
    @IsTest
    static void t_filters_values_plus_null() {
        seed();
        Map<String, List<Object>> map2 = new Map<String, List<Object>>();
        map2.put('DecisionReason', new List<Object>{ 'Risk', 'nullcheck' });
        map2.put('Stage',          new List<Object>{ 'Final', 'Review' });

        String filters = buildFilters(map2);

        Test.startTest();
        Map<String,Object> res = TechnologyDecision_DataTableHandler.getTechnologyDecision(0, 200, filters, 'alldecision', null);
        Test.stopTest();
        System.assert(res.containsKey('decisionRecordsCount'));
    }

    // 4) getUniqueValues → both alldecision and mydecision (OwnerId)
    @IsTest
    static void t_uniqueValues_all_and_my() {
        seed();

        // Ensure one record is owned by the running user so "mydecision" returns something
        TechnologyDecision__c one = [SELECT Id FROM TechnologyDecision__c WHERE Name = 'Alpha TD' LIMIT 1];
        update new TechnologyDecision__c(Id = one.Id, OwnerId = UserInfo.getUserId());

        // Use the labels your method expects: 'Status', 'Stage', 'Decision Reason'
        List<String> ask = new List<String>{ 'Status', 'Stage', 'Decision Reason' };

        Test.startTest();
        Map<String,Object> allMap = TechnologyDecision_DataTableHandler.getUniqueValues(ask, 'alldecision');
        Map<String,Object> myMap  = TechnologyDecision_DataTableHandler.getUniqueValues(ask, 'mydecision');
        Test.stopTest();

        System.assert(allMap.containsKey('Status'), 'Expect Status bucket in all');
        System.assert(((List<Object>)allMap.get('Status')).size() > 0, 'All should have counts');
        System.assert(myMap.containsKey('Status'), 'Expect Status bucket in my');
    }

    // 5) getRecordWithFieldSet → cover success if a field set exists, else cover the exception branch
    @IsTest
    static void t_recordWithFieldSet() {
        seed();
        Id anyId = [SELECT Id FROM TechnologyDecision__c LIMIT 1].Id;

        // Discover any field set on the object
        Schema.SObjectType objType = Schema.getGlobalDescribe().get('TechnologyDecision__c');
        Map<String, Schema.FieldSet> fs = objType.getDescribe().fieldSets.getMap();

        if (!fs.isEmpty()) {
            // happy path
            String anyFsName = fs.keySet().iterator().next();
            Test.startTest();
            Map<String, Object> res = TechnologyDecision_DataTableHandler.getRecordWithFieldSet(String.valueOf(anyId), 'TechnologyDecision__c', anyFsName);
            Test.stopTest();
            System.assertNotEquals(null, res, 'Field set response should not be null when FS exists');
        } else {
            // exception path (still covers the early describe lines)
            try {
                Test.startTest();
                TechnologyDecision_DataTableHandler.getRecordWithFieldSet(String.valueOf(anyId), 'TechnologyDecision__c', 'NonExistent_FS');
                Test.stopTest();
                System.assert(false, 'Should have thrown for missing field set');
            } catch (Exception e) {
                System.assert(e.getMessage().contains('Field Set'), 'Expect missing field set message');
            }
        }
    }

    // 6) Label→API resolver called directly
    @IsTest
    static void t_labelToApi() {
        Map<String,String> L = tdLabels();
        Test.startTest();
        List<String> s1 = TechnologyDecision_DataTableHandler.getApiNamesFromLabels('TechnologyDecision__c', L.get('Status'));
        List<String> s2 = TechnologyDecision_DataTableHandler.getApiNamesFromLabels('TechnologyDecision__c', L.get('Stage'));
        List<String> s3 = TechnologyDecision_DataTableHandler.getApiNamesFromLabels('TechnologyDecision__c', L.get('DecisionReason'));
        Test.stopTest();
        System.assertNotEquals(null, s1);
        System.assertNotEquals(null, s2);
        System.assertNotEquals(null, s3);
    }
