
public class TechnologyDecision_DataTableHandler {
    public static Id userId = UserInfo.getUserId();
    static final String OBJECT_NAME = 'TechnologyDecision__c';
    static final String FIELDS_TO_BE_QUERIED_NEW = 'Id, Name, Status__c, Stage__c, Estimated_Decision_Date__c,Decision_Reason__c, TechnologyDecision_Relationship__c  ';
	 // Method to fetch Technology Decision
    @AuraEnabled(cacheable=true)
    public static Map<String, Object> getTechnologyDecision(Integer offsetSize, Integer limitSize, String filters, string allOrMy, string searchKey) {
        try {
            List<TechnologyDecision__c> decisionRecords;
            Map<String, Object> result = new Map<String, Object>();
            Integer decisionRecordsCount = 0;
            String query =
      					  'SELECT ' +
      					   FIELDS_TO_BE_QUERIED_NEW +
      					  'FROM ' +
      					   OBJECT_NAME +
      					   ' ';
         String countQuery = 'SELECT COUNT()' + 'FROM ' + OBJECT_NAME + ' ';
    /*  countQuery += (!countQuery.contains('WHERE')
        ? ' WHERE Waiver_Id__r.OwnerId = \'' + userId + '\' '
        : ' AND Waiver_Id__r.OwnerId = \'' + userId + '\' ');
    } */
              //Search logic
    if (String.isNotBlank(searchKey)) {
      String textFilter = '\'%' + searchKey + '%\'';
      if (!query.contains('WHERE')) {
        query += ' WHERE ';
        countQuery += ' WHERE ';
      } else {
        query += ' AND ';
        countQuery += ' AND ';
      }
      query = buildSearchTerm(query, textFilter);
        countQuery = buildSearchTerm(countQuery, textFilter);
        system.debug('Checking Search Key '+ query );
    }
            string fieldApiName='';
            system.debug('filters '+filters);
            if (!String.isBlank(filters)) {
          List<Object> filtersList = (List<Object>) JSON.deserializeUntyped(filters);
          
          // To track if only NULL/nullcheck filters are present
          Boolean onlyNullChecks = true;
          system.debug('filtersList '+filtersList);
         // system.debug('filtersList '+filtersList[0]);
              
          
          if (filtersList.size() > 0) {              
              //String filterQuery = ' AND (';
              system.debug('checking here query '+query);
              String filterQuery = (!query.contains(' WHERE ') ? ' WHERE (' : ' AND (');
              system.debug('checking here'+filterQuery);
            
              Map<String, List<String>> fieldSpecificFilterValuesMap = new Map<String, List<String>>();
              system.debug('checking here');
              // Construct the filter query
              for (Object filter : filtersList) {
                  Map<String, Object> filterMap = (Map<String, Object>) filter;
                  string jsonstring =JSON.serialize(filterMap.values());
                  Boolean hasLetters = Pattern.compile('[a-zA-Z]').matcher(jsonstring).find();
                  system.debug('checking here'+hasLetters);
                  system.debug('checking here'+String.valueOf(filterMap.values()));
                  system.debug('checking here'+JSON.serialize(filterMap.values()));
                  system.debug('checking here'+filter);
                   system.debug('checking here'+filterMap.keySet());
                  if( hasLetters == true){
                  for (String key : filterMap.keySet()) {
                      system.debug('checking here'+ key);
                      if (filterMap.get(key) != null && filterMap.get(key) instanceof List<Object>) {
                          List<Object> filterValuesList = (List<Object>) filterMap.get(key);
                          system.debug('checking here'+ key);
                           List<String> apiNames = TechnologyDecision_DataTableHandler.getApiNamesFromLabels('TechnologyDecision__c', key);
                              fieldApiName =apiNames[0];
                          system.debug('checking here'+ filterValuesList);
                          Set<String> stringFilterValues = new Set<String>();
                          Boolean includeNull = false;
                          
                          // Loop through filter values
                          for (Object value : filterValuesList) {
                              system.debug('checking here'+ value);
                              //value='Approved';
                             
                              system.debug('filter checking here ' +String.valueOf(value));
                             
                              if (String.valueOf(value) == 'nullcheck') {
                                  includeNull = true; // Mark nullcheck
                              }else if(String.valueOf(value) == 'No Data'){
                                  includeNull = true; // Mark nullcheck
                              }else {
                                  stringFilterValues.add(String.valueOf(value)); // Add non-null values
                                  onlyNullChecks = false; // There are other values besides nullcheck
                              }
                          }
                          
                          // Only process fields that have filter values (either non-null or nullcheck)
                          if (!stringFilterValues.isEmpty() || includeNull) {
                              
                             
                              
                              /*Feb 15th Changes*/
                             
                              
                             
                              // Add the field condition to the query
                              filterQuery += '(';
                              
                              if (includeNull && onlyNullChecks) {
                                  // If only NULL checks are present for this field, do a NULL check
                                  filterQuery += fieldApiName + ' = NULL';
                              } else {
                                  // If there are non-null values, create the IN condition
                                  if (!stringFilterValues.isEmpty()) {
                                      List<String> quotedValues = new List<String>();
                                      for (String value : stringFilterValues) {
                                          quotedValues.add('\'' + value + '\'');
                                      }
                                      String quotedValuesString = String.join(quotedValues, ', ');
                                      filterQuery += fieldApiName + ' IN (' + quotedValuesString + ')';
                                  }
                                  
                                  // Include NULL check if needed (OR between IN and NULL)
                                  if (includeNull) {
                                      if (!stringFilterValues.isEmpty()) {
                                          filterQuery += ' OR ';
                                      }
                                      filterQuery += fieldApiName + ' = NULL';
                                  }
                              }
                              
                              // Close the condition for this field
                              filterQuery += ')';
                              filterQuery += ' AND ';
                          }
                      }
                  }
              }
              }
              // Clean up the final query (remove last AND and close parentheses)
              system.debug('Check filterQuery '+filterQuery);
              String lastChar = filterQuery.substring(filterQuery.length() - 1);
              system.debug('Check filterQuery '+lastChar);
              if(lastChar=='('){
                  filterQuery='';
              }else{
              filterQuery = filterQuery.removeEnd(' AND ') + ') ';
              }
              system.debug('Check filterQuery After '+filterQuery);
              query += filterQuery;
              countQuery += filterQuery;
              system.debug('Check query filterQuery After '+query);
              system.debug('Check query filterQuery After '+countQuery);
              
          }
      }
   //Add for All or My waivers
    if (allOrMy == 'mydecision') {
      query += (!query.contains('WHERE')
        ? ' WHERE OwnerId = \'' + userId + '\' '
        : ' AND OwnerId = \'' + userId + '\' ');
         countQuery += (!countQuery.contains('WHERE')
        ? ' WHERE OwnerId = \'' + userId + '\' '
        : ' AND OwnerId = \'' + userId + '\' ');
    }
            system.debug('query '+query);
            decisionRecords = Database.query(query);
            decisionRecordsCount = Database.countQuery(countQuery);
            system.debug('decisionRecordsCount '+decisionRecordsCount);
            result.put('decisionRecords', decisionRecords);
    		result.put('decisionRecordsCount', decisionRecordsCount);
            return result;
        } catch (Exception ex) {
            throw new AuraHandledException('Error fetching Accounts: ' + ex.getMessage());
        }
	}
     //Added the fields that we are looking to have filter options. If the field from Relationship record use the formula field in the value and the label in the key
  public static Map<String, String> fieldList = new Map<String, String>{
    'Decision Reason' => 'Decision_Reason__c',
    'Status/Stage' => 'Status__c'
       // 'Stage' => 'Stage__c'
  };
       private static String buildSearchTerm(String query, String searchKey) {
    query +=
      '( Name LIKE ' +
      searchKey +
        'OR Stage__c   LIKE ' +
      searchKey +
        'OR Status__c   LIKE ' +
      searchKey +
        'OR Decision_Reason__c    LIKE ' +
      searchKey +
      ' ) ';
    return query;
  }
    @AuraEnabled(cacheable=true)//Map<String, List<Object>>
  public static Map<String, Object> getUniqueValues(
    List<String> fieldApiName,
    String allOrMy
  ) {
    try {
      Map<String, List<AggregateResult>> results = new Map<String, List<AggregateResult>>();
     // Map<String, String> fieldLabel = getStagePicklistValues();
      //Map<String, List<Object>> fieldUniqueMap = new Map<String, List<Object>>();
      Map<String, Object> fieldUniqueMap = new Map<String, Object>();
      String condition = '';
      if (allOrMy == 'mydecision') {
        condition += ' WHERE OwnerId = \'' + userId + '\' ';
      }

      Integer maxQueriesAllowed = Limits.getLimitQueries() - Limits.getQueries(); // Just for safety

        system.debug('fieldApiName '+ fieldApiName);
        String query = '';
        string fieldApiNameString = string.join(fieldApiName,',');
        system.debug('fieldApiNameString '+ fieldApiNameString);
       /* if(fieldApiNameString.contains('Status')){
            query = 'SELECT Status__c, COUNT(Id) ' +
                    'FROM TechnologyDecision__c  ' + condition +
                    ' GROUP BY Status__c';
            results.put('Status', Database.query(query));
        } */
        if(fieldApiNameString.contains('Decision Reason')){
            query = 'SELECT Decision_Reason__c, COUNT(Id) ' +
                    'FROM TechnologyDecision__c  ' + condition +
                    ' GROUP BY Decision_Reason__c';
            results.put('Decision Reason', Database.query(query));
        }
       /* if(fieldApiNameString.contains('Stage')){
            query = 'SELECT Stage__c, COUNT(Id) ' +
                    'FROM TechnologyDecision__c  ' + condition +
                    ' GROUP BY Stage__c';
            results.put('Stage', Database.query(query));
        } */
        system.debug('results '+ results);

        
      
        
      for (String field : results.keySet()) {
        List<Object> uniqueValues = new List<Object>();
          /*Feb 15th Changes - 914*/
          system.debug('field 75 '+ field);
          
              for (AggregateResult ar : results.get(field)) {
                  system.debug('ar ===>>> '+ar);
                  
                   System.debug('uniqueValues '+(String) ar.get((fieldList.get(field))));
                  Map<String, Object> uni = new Map<String, Object>();
                 
                  uni.put(
                      'value',
                      (String) ar.get((fieldList.get(field)))
                  );
                  uni.put('count', (Integer) ar.get('expr0'));
                  
                  uniqueValues.add((Object) uni);
              }
                  
                  System.debug('uniqueValues 90 '+uniqueValues);
                 
            
          fieldUniqueMap.put(field, uniqueValues);
          }
        if(fieldApiName.contains('Status')){
         List<PortfolioItem> lstSatageStage = getStatusStage();
          fieldUniqueMap.put('Status/Stage', lstSatageStage);
        }
      return fieldUniqueMap;
    } catch (Exception e) {
      System.debug('message' + e.getMessage());
      System.debug('stack' + e.getStackTraceString());
      throw new AuraHandledException(e.getMessage());
    }
  }

    
    // Wrapper to return Field Set details
    public class ReturnWP {
        @AuraEnabled public List<String> apiNames { get; set; }
        @AuraEnabled public List<String> labels   { get; set; }
    }


@AuraEnabled(cacheable=true)
public static Map<String, Object> getRecordWithFieldSet(
    String recordId, String objectName, String fieldSetName
) {
    // Get describe info
    Schema.SObjectType objType = Schema.getGlobalDescribe().get(objectName);
    Schema.DescribeSObjectResult objDescribe = objType.getDescribe();
    Map<String, Schema.FieldSet> fieldSetMap = objDescribe.fieldSets.getMap();
    Schema.FieldSet fieldSet = fieldSetMap.get(fieldSetName);

    if (fieldSet == null) {
        throw new AuraHandledException('Field Set not found: ' + fieldSetName);
    }

    // Build dynamic SOQL
    List<String> fields = new List<String>();
    for (Schema.FieldSetMember f : fieldSet.getFields()) {
        fields.add(f.getFieldPath());
    }

    String soql = 'SELECT ' + String.join(fields, ',') +
                  ' FROM ' + objectName +
                  ' WHERE Id = :recordId LIMIT 1';
    System.debug('SOQL: ' + soql);
    SObject recordData = Database.query(soql);

    // Prepare response: key = Label, value = field value (or fallback)
    Map<String, Object> response = new Map<String, Object>();
    for (Schema.FieldSetMember f : fieldSet.getFields()) {
        Object rawValue = recordData.get(f.getFieldPath());
        response.put(
            f.getLabel(),
            rawValue != null ? rawValue : '' // always include field
        );
    }
    return response;
}

    
	public static List<String> getApiNamesFromLabels(String objectApiName, String labelName) {
        List<String> matchingApiNames = new List<String>();
        if(labelName=='Status/Stage'){
            labelName='Status';
        }
        // Get describe for the object
        Schema.SObjectType objType = Schema.getGlobalDescribe().get(objectApiName);
        Schema.DescribeSObjectResult objDescribe = objType.getDescribe();
        
        // Get all fields
        Map<String, Schema.SObjectField> fields = objDescribe.fields.getMap();
        
        for (String apiName : fields.keySet()) {
            Schema.DescribeFieldResult fieldDesc = fields.get(apiName).getDescribe();
            
            // Compare the label
            if (fieldDesc.getLabel() == labelName) {
                matchingApiNames.add(apiName);
            }
        }
        
        return matchingApiNames;
    }
    
       @AuraEnabled(cacheable=true)
    public static Map<String, String> getStagePicklistValues() {
        Map<String, String> stageLabelMap = new Map<String, String>();
        Schema.DescribeFieldResult fieldResult = TechnologyDecision__c.Stage__c.getDescribe();
        Schema.DescribeFieldResult fieldResult2 = TechnologyDecision__c.Status__c.getDescribe();
        List<Schema.PicklistEntry> picklistValues = fieldResult.getPicklistValues();
        List<Schema.PicklistEntry> picklistValues2 = fieldResult2.getPicklistValues();
        
        for (Schema.PicklistEntry entry : picklistValues) {
            stageLabelMap.put(entry.getValue(), entry.getLabel());
        }
        if(!picklistValues2.IsEmpty()){
        for (Schema.PicklistEntry entry1 : picklistValues2) {
            stageLabelMap.put(entry1.getValue(), entry1.getLabel());
        }
        }
        return stageLabelMap;
    }
    
    public class DomainItem {
        @AuraEnabled public String label;
        @AuraEnabled public Integer count;
    }

    public class PortfolioItem {
        @AuraEnabled public String label;
        @AuraEnabled public Integer count;
        @AuraEnabled public List<DomainItem> domains;
    }
    @AuraEnabled(cacheable=true)
    public static List<PortfolioItem> getStatusStage() {
        //String whereClause = buildWhereConditionForNames(filterNames);
       // system.debug('whereClause '+whereClause);
         string query = 'SELECT Status__c portfolioName, Stage__c domainName,COUNT(Id) recordCount FROM TechnologyDecision__c  '
             		 +
                    ' GROUP BY  Status__c, Stage__c ORDER BY Status__c ' ;
           system.debug('query 1520 '+query);
        List<AggregateResult> results = Database.query(query);
        system.debug('results '+results);
        Map<String, String> fieldMap = getStagePicklistValues();

        // Step 2: Group by Portfolio
        Map<String, PortfolioItem> portfolioMap = new Map<String, PortfolioItem>();

        for (AggregateResult ar : results) {
            system.debug('ar '+ar);
            String portfolioName = fieldMap.get((String)ar.get('portfolioName'));
            String domainName = fieldMap.get((String)ar.get('domainName'));
            Integer count = (Integer)ar.get('recordCount');
			system.debug('portfolioMap 404 '+ portfolioName);
            if (String.isBlank(portfolioName)) {
                portfolioName = 'No Data';
            }
            if (String.isBlank(domainName)) {
                domainName = 'No Data';
            }
			system.debug('portfolioMap 411 '+ portfolioName);
            // Create portfolio if missing
            if (!portfolioMap.containsKey(portfolioName)) {
                PortfolioItem p = new PortfolioItem();
                p.label = portfolioName + ' (0)'; // Will update later with total
                p.count = 0;
                p.domains = new List<DomainItem>();
                portfolioMap.put(portfolioName, p);
            }
			
            // Add domain to portfolio
            DomainItem d = new DomainItem();
            d.label = domainName + ' (' + count + ')';
            d.count = count;
            portfolioMap.get(portfolioName).domains.add(d);

            // Increase portfolio count
            portfolioMap.get(portfolioName).count += count;
            system.debug('portfolioMap 429 '+ portfolioName);
            system.debug('portfolioMap 430 '+ portfolioMap);
        }
		
        // Step 3: Update portfolio labels with correct total
        for (PortfolioItem p : portfolioMap.values()) {
            p.label = p.label.substring(0, p.label.lastIndexOf('(')).trim() + ' (' + p.count + ')';
        }
		system.debug('portfolioMap '+ portfolioMap);
        return new List<PortfolioItem>(portfolioMap.values());
    }

}
